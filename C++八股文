0、对多态和动态绑定的理解
多态可以给使用者隐藏多个类型信息，使用者只需要通过一个父类的类型，就可以操作多个类型的对象，并且不同类型的对象的某些（虚函数）方法可以展现出不同的行为。
通过父类型操作的对象，只有在运行期间才能确定其类型，这个怎么理解呢？
A *p = new D1();  
对于这种情况，看起来类型在编译期间就确定了，再看下面一种情况：
A *p = nullptr;
If(str == "1") p = new D1();  
else p = new D2();  
这种情况下，编译器就无能为力了，只能在运行时才能知道用户创建了什么类型。
因此通过父类型调用具体对象的多态方法时，需要在运行期间去决定使用那个函数。大多数编译器通过虚函数表的方式实现这个需求，编译期间即可确定类型对应的虚函数，存放在.data区域，在创建具体类型时，通过编译器提前插入的代码，将虚函数表指针绑定虚函数表，这就是动态绑定。

1、虚函数
大多数编译器通过虚函数表实现。拥有虚函数的类，它的对象内存的开始将会是一个4字节的指针，指向虚函数表的地址，在调用时从指向的虚函数表中获取函数地址。

class Base {
public:
    Base() {};
    virtual void write() {}
    virtual void print() {}
};
class D1 : public Base {
public:
    D1() {};
    virtual void d_print() {}
    virtual void print() {}
    virtual void write() {}
};
int main() {
    Base* d1 = new D1();
    Base* d2 = new D1();
    return 0;
}

	• 多个虚函数在表中的存放顺序？
	g++ -fdump-class-hierarchy -g vtable.cpp ，这个命令可以输出内存布局信息
	可以看到虚函数表存放的顺序和父类中定义的顺序相关
	
	• 在调用一个虚函数是怎么从表中查到？
	实际上，函数的调用会翻译成这种方式：(*(p->ptr))[n]，n在编译期间就确定了
	
	• 子类中自己的虚函数怎么存表？
	自己的虚函数会往后排
	
	• 同一个类的多个对象，是否共用一个表？
	
	通过gdb查看，会共用

2、为什么构造函数不能是虚函数
	• 虚表指针的初始化在构造函数？
	如果这个条件成立，那么很显然，调用构造函数的时候，需要从虚表获取，此时虚表指针还没有初始化，鸡生蛋，蛋生鸡？
	• 虚表指针在构造函数之前初始化？
	如果成立，确实不好解释
	• 构造函数不需要动态绑定，因此没必要是虚函数？
	编译期间生成程序的时候，知道构造对象类型， 所以确实没必要动态绑定。
   知乎的一个解释：
当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。
虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。
vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。
如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。
因此，构造函数不可以是虚函数。


作者：算法集市
链接：https://zhuanlan.zhihu.com/p/255274039
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


3、为什么父类的析构函数需要是虚函数
Base *p = new Derive();
Delete p;
其中，Derive是Base的子类
如果Base的析构不是虚函数，那么delete对象p时，直接调用Base的析构，而不去调用Derive的析构。
反之，会去调用子类的析构函数，而调用子类的析构函数，自然会先去调用父类的析构函数


4.重载、覆盖（重写）、隐藏区别
重载， 参数不同的同名函数，不关心返回值。并不是两个函数的名字相同就能构成重载。全局函数和类的成员函数同名不算重载，因为函数的作用域不同。对于函数重载，out(float a)和out( int a) 当调用 out(1)时，是正确的， 当调用out(0.5)时，编译错误，因为编译器无法确定应该如何进行类型转换。
隐藏， 是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
覆盖， 重写的基类中被重写的函数必须有virtual修饰。
函数重载只是动态的多态性，在编译阶段，给不同的函数不同的函数名，而虚函数实现运行时多态。
来源：网上查到的，具体链接待整理

5.内联函数(inline)知识点
5.1 内敛函数用在哪？
关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。
5.2 内联函数与宏定义define的区别：
5.2.1．C中使用define这种形式宏定义的原因是因为C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了参数压栈，代码生成等一系列的操作。因此，效率很高，这是它在C中被使用的一个主要原因。
5.2.2．这种宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型。这样，它的使用就存在着一系列的隐患和局限性。
5.2.3．在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将this指针放在合适的位置）。
5.2.4．inline推出的目的，也正是为了取代这种表达式形式的宏定义，它消除了宏定义的缺点，同时又很好地继承了宏定义的优点。
来源：https://baike.baidu.com/item/inline/10566989?fr=aladdin

6.指针常量 VS 常量指针
6.1 指针常量
int a，b;
int * const p = &a; //指针常量 ：p首先是个常量，然后这个常量指向变量a。所以p自己不能变。
*p=9;//操作成功
p=&b;//操作错误

6.2 常量指针 
int a，b;
const int *p=&a; //常量指针 ：p首先是个指针，然后这个指针指向了一个常量a。所以不能通过*p去改变a。
//那么分为一下两种操作
*p=9;//操作错误
p=&b;//操作成功

6.3 指向常量的指针常量
int a，b;
const int * const b = &a;//指向常量的指针常量
//那么分为一下两种操作
*p=9;//操作错误
p=&b;//操作错误