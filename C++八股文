0、对多态和动态绑定的理解
多态可以给使用者隐藏多个类型信息，使用者只需要通过一个父类的类型，就可以操作多个类型的对象，并且不同类型的对象的某些（虚函数）方法可以展现出不同的行为。
通过父类型操作的对象，只有在运行期间才能确定其类型，这个怎么理解呢？
A *p = new D1();  
对于这种情况，看起来类型在编译期间就确定了，再看下面一种情况：
A *p = nullptr;
If(str == "1") p = new D1();  
else p = new D2();  
这种情况下，编译器就无能为力了，只能在运行时才能知道用户创建了什么类型。
因此通过父类型调用具体对象的多态方法时，需要在运行期间去决定使用那个函数。大多数编译器通过虚函数表的方式实现这个需求，编译期间即可确定类型对应的虚函数，存放在.data区域，在创建具体类型时，通过编译器提前插入的代码，将虚函数表指针绑定虚函数表，这就是动态绑定。

1、虚函数
大多数编译器通过虚函数表实现。拥有虚函数的类，它的对象内存的开始将会是一个4字节的指针，指向虚函数表的地址，在调用时从指向的虚函数表中获取函数地址。

class Base {
public:
    Base() {};
    virtual void write() {}
    virtual void print() {}
};
class D1 : public Base {
public:
    D1() {};
    virtual void d_print() {}
    virtual void print() {}
    virtual void write() {}
};
int main() {
    Base* d1 = new D1();
    Base* d2 = new D1();
    return 0;
}

	• 多个虚函数在表中的存放顺序？
	g++ -fdump-class-hierarchy -g vtable.cpp ，这个命令可以输出内存布局信息
	可以看到虚函数表存放的顺序和父类中定义的顺序相关
	
	• 在调用一个虚函数是怎么从表中查到？
	实际上，函数的调用会翻译成这种方式：(*(p->ptr))[n]，n在编译期间就确定了
	
	• 子类中自己的虚函数怎么存表？
	自己的虚函数会往后排
	
	• 同一个类的多个对象，是否共用一个表？
	
	通过gdb查看，会共用

2、为什么构造函数不能是虚函数
	• 虚表指针的初始化在构造函数？
	如果这个条件成立，那么很显然，调用构造函数的时候，需要从虚表获取，此时虚表指针还没有初始化，鸡生蛋，蛋生鸡？
	• 虚表指针在构造函数之前初始化？
	如果成立，确实不好解释
	• 构造函数不需要动态绑定，因此没必要是虚函数？
	编译期间生成程序的时候，知道构造对象类型， 所以确实没必要动态绑定。
   知乎的一个解释：
当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。
虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。
vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。
如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。
因此，构造函数不可以是虚函数。


作者：算法集市
链接：https://zhuanlan.zhihu.com/p/255274039
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


3、为什么父类的析构函数需要是虚函数
A *p = new D();
Delete p;
如果A的析构不是虚函数，那么delete时，直接调用A的析构，而不去调用D的析构。
反之，会去调用子类的析构函数，而调用子类的析构函数，自然会先去调用父类的析构函数
