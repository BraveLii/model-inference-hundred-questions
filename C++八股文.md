0、对多态和动态绑定的理解
多态可以给使用者隐藏多个类型信息，使用者只需要通过一个父类的类型，就可以操作多个类型的对象，并且不同类型的对象的某些（虚函数）方法可以展现出不同的行为。
通过父类型操作的对象，只有在运行期间才能确定其类型，这个怎么理解呢？
A *p = new D1();  
对于这种情况，看起来类型在编译期间就确定了，再看下面一种情况：
A *p = nullptr;
If(str == "1") p = new D1();  
else p = new D2();  
这种情况下，编译器就无能为力了，只能在运行时才能知道用户创建了什么类型。
因此通过父类型调用具体对象的多态方法时，需要在运行期间去决定使用那个函数。大多数编译器通过虚函数表的方式实现这个需求，编译期间即可确定类型对应的虚函数，存放在.data区域，在创建具体类型时，通过编译器提前插入的代码，将虚函数表指针绑定虚函数表，这就是动态绑定。

1、虚函数
大多数编译器通过虚函数表实现。拥有虚函数的类，它的对象内存的开始将会是一个4字节的指针，指向虚函数表的地址，在调用时从指向的虚函数表中获取函数地址。

class Base {
public:
    Base() {};
    virtual void write() {}
    virtual void print() {}
};
class D1 : public Base {
public:
    D1() {};
    virtual void d_print() {}
    virtual void print() {}
    virtual void write() {}
};
int main() {
    Base* d1 = new D1();
    Base* d2 = new D1();
    return 0;
}

	• 多个虚函数在表中的存放顺序？
	g++ -fdump-class-hierarchy -g vtable.cpp ，这个命令可以输出内存布局信息
	可以看到虚函数表存放的顺序和父类中定义的顺序相关
	
	• 在调用一个虚函数是怎么从表中查到？
	实际上，函数的调用会翻译成这种方式：(*(p->ptr))[n]，n在编译期间就确定了
	
	• 子类中自己的虚函数怎么存表？
	自己的虚函数会往后排
	
	• 同一个类的多个对象，是否共用一个表？
	
	通过gdb查看，会共用

2、为什么构造函数不能是虚函数
	• 虚表指针的初始化在构造函数？
	如果这个条件成立，那么很显然，调用构造函数的时候，需要从虚表获取，此时虚表指针还没有初始化，鸡生蛋，蛋生鸡？
	• 虚表指针在构造函数之前初始化？
	如果成立，确实不好解释
	• 构造函数不需要动态绑定，因此没必要是虚函数？
	编译期间生成程序的时候，知道构造对象类型， 所以确实没必要动态绑定。
   知乎的一个解释：
当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。
虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。
vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。
如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。
因此，构造函数不可以是虚函数。


作者：算法集市
链接：https://zhuanlan.zhihu.com/p/255274039
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


3、为什么父类的析构函数需要是虚函数
Base *p = new Derive();
Delete p;
其中，Derive是Base的子类
如果Base的析构不是虚函数，那么delete对象p时，直接调用Base的析构，而不去调用Derive的析构。
反之，会去调用子类的析构函数，而调用子类的析构函数，自然会先去调用父类的析构函数


4.重载、覆盖（重写）、隐藏区别
重载， 参数不同的同名函数，不关心返回值。并不是两个函数的名字相同就能构成重载。全局函数和类的成员函数同名不算重载，因为函数的作用域不同。对于函数重载，out(float a)和out( int a) 当调用 out(1)时，是正确的， 当调用out(0.5)时，编译错误，因为编译器无法确定应该如何进行类型转换。
隐藏， 是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
覆盖， 重写的基类中被重写的函数必须有virtual修饰。
函数重载只是动态的多态性，在编译阶段，给不同的函数不同的函数名，而虚函数实现运行时多态。
来源：网上查到的，具体链接待整理

5.内联函数(inline)知识点
5.1 内敛函数用在哪？
关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。
5.2 内联函数与宏定义define的区别：
5.2.1．C中使用define这种形式宏定义的原因是因为C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了参数压栈，代码生成等一系列的操作。因此，效率很高，这是它在C中被使用的一个主要原因。
5.2.2．define这种宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型。这样，它的使用就存在着一系列的隐患和局限性。
5.2.3．在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将this指针放在合适的位置）。
5.2.4．inline推出的目的，也正是为了取代这种表达式形式的宏定义，它消除了宏定义的缺点，同时又很好地继承了宏定义的优点。
来源：https://baike.baidu.com/item/inline/10566989?fr=aladdin

6.指针常量 VS 常量指针
6.1 指针常量
int a，b;
int * const p = &a; //指针常量 ：p首先是个常量，然后这个常量指向变量a。所以p自己不能变。
*p=9;//操作成功
p=&b;//操作错误

6.2 常量指针 
int a，b;
const int *p=&a; //常量指针 ：p首先是个指针，然后这个指针指向了一个常量a。所以不能通过*p去改变a。
//那么分为一下两种操作
*p=9;//操作错误
p=&b;//操作成功

6.3 指向常量的指针常量
int a，b;
const int * const b = &a;//指向常量的指针常量
//那么分为一下两种操作
*p=9;//操作错误
p=&b;//操作错误

7.编译原理理解记录
程序编写到运行需要经历预编译，编译，链接，生成exe等阶段。.
cpp与.h的的作用在于.h中进行声明，cpp在编译的时候，遇到声明会做一个标记，然后在链接的时候会找到相应的函数。
每个cpp是单独编译的。不然编译顺序不同，结果不同了。
.h中不要包含变量的定义，因为定义后，如果多个cpp引用这个变量，在链接阶段会出现重复定义
一个工程中，是不会出现一模一样的函数定义的。那样在链接的时候会报错。

8.函数有关的知识点
8.1 函数的参数缺省值只能出现在函数的声明中，而不能出现在定义体中。

9.局部变量能否和全局变量重名？ 　
答：能，局部会屏蔽全局。要用全局变量，需要使用”::” ;局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。
对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。

10.extern修饰变量的声明
如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。
这里需要注意的是，被引用的变量v的链接属性必须是外链接（external）的，也就是说a.c要引用到v，不只是取决于在a.c中声明extern int v，还取决于变量v本身是能够被引用到的。

11.static知识点
1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，
如果没有初始值系统用默认值初始化它。在每次调用时，其值为上一次调用后改变的值，调用结束后不释放空间。此变量只在声明变量的文件内可见。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定义为static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在static函数内不能访问非静态成员。
5. 静态变量什么时候初始化：静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。
而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造。

12.STL里resize和reserve的区别？
resize()：改变当前容器内含有元素的数量(size())。以vector<int> A(3,1)为例，如果A.resize(10), 这个新size是10，
超过了之前的3，那么会在之前元素的后面生产7个新元素，新元素默认为0；
reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，
那么会重新分配一块能存len个对象的空间，然后把之前A.size()个对象通过copy construtor复制过来，销毁之前的内存。

13.源码到可执行文件的过程？
1）预编译
主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下
1、删除所有的#define，展开所有的宏定义。
2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。
4、删除所有的注释，“//”和“/**/”。
5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。
6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。
2）编译
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。
1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
4、优化：源代码级别的一个优化过程。
5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。
3）汇编
将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。
4）链接
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：
1、静态链接：
函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
2、动态链接：
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

参考链接：网上搜到的资料。。。具体链接待确认

14.new和malloc的区别？
1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；
2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。
3、new不仅分配一段内存，而且会调用构造函数，malloc不会。
4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。
5、new是一个操作符可以重载，malloc是一个库函数。
6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。
7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。
8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。

15.C++的内存管理是怎样的？
在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
只读数据段：存虚函数表（里面存了虚函数的地址，指向代码段）
数据段：存储程序中已初始化的全局变量和静态变量
bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。
全局存储区 = 数据段 + bss段
堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。
映射区:存储动态链接库以及调用mmap函数进行的文件映射
栈区：使用栈空间存储函数的返回地址、参数、局部变量、返回值

16.一个类，里面有static，virtual，之类的，来说一说这个类的内存分布？
1、static修饰符
1）static修饰成员变量
对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。
因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。
2）static修饰成员函数
与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。
Static修饰的成员函数，在代码区分配内存。
2、C++继承和虚函数
C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。
动态多态实现有几个条件：
(1) 虚函数；
(2) 一个基类的指针或引用指向派生类的对象；
基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。
每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。
虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。
3、virtual修饰符
如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。
如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。
如果类中成员是virtual属性，会隐藏父类对应的属性。

https://github.com/BraveLii/model-inference-hundred-questions/blob/main/sys_mem.jpg?raw=true